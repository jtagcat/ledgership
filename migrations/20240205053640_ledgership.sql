-- TODO: GET /grants {
CREATE TYPE IF NOT EXISTS grantT AS (
    service	TEXT,
    data	TEXT,
);

-- TODO: POST /package {admin}
-- TODO: GET /package
--        -> {admin} returns all + subscriber count
-- TODO: GET /package/:id {user:own}
--        -> {admin} returns subscribers
-- TODO: POST /package/:id/successor/:id {admin} - moves subscriptions and package:addon_of, creates a new subscription on price change; TODO: test edge-cases
-- TODO: PUT /package/:id/publish_for/group,group,, {admin}: publish_for
-- TODO: PUT /package/:id/addon_of/id,id, {admin}: addon_of
--
-- TODO: might want to break this up
CREATE TABLE IF NOT EXISTS packages (
    id              INT                 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    author          TEXT                NOT NULL,
    created_at      CURRENT_TIMESTAMP   NOT NULL,
    successor       INT                 REFERENCES packages, -- mutable if not NULL; TODO: test for multi-parent

    -- v display to non-admins
    name            TEXT    NOT NULL,
    description     TEXT,
    price           NUMERIC NOT NULL,
    currency        TEXT    NOT NULL,
    -- ^

    grants	    grantT[],

    -- v both conditions must be met
    addon_of	    ELEMENT REFERENCES packages, -- mutable; TODO: might fail
    publish_for     TEXT[], -- mutable; /package for non-admin
    -- ^ packages present in user/{deals} transactions are always queriable by user
);
CREATE INDEX IF NOT EXISTS packages_price_index ON subscriptions (id) WITH price;
CREATE INDEX IF NOT EXISTS packages_addons_index ON subscriptions (addon_of) WITH id;
CREATE INDEX IF NOT EXISTS packages_grants_index ON subscriptions (id) WITH grants;
CREATE INDEX IF NOT EXISTS packages_display_index ON subscriptions (publish_for,addon_of);
--
CREATE TABLE IF NOT EXISTS packages_order (
    order   ELEMENT REFERENCES packages, --TODO: might fail
);

-- TODO: POST /sub
-- TODO: DELETE /sub/:id
--           -> when notBefore is before now
--           -> or {admin}
-- TODO: PATCH /sub/:id?notAfter=date {user:own,deals:rw}
-- TODO: GET /sub/:user {user:own,deals:ro,admin:rw}
-- TODO: PUT /sub/:id/mail/name
-- TODO: PUT /sub/:id/mail/email
CREATE TABLE IF NOT EXISTS subscriptions (
    id              INT         GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user            TEXT        NOT NULL, -- {deals,admin:rw}

    package                  INT         NOT NULL REFERENCES packages, -- mutable by PATCH /package/:id?successor=id
    notBefore                TIMESTAMP   NOT NULL,
    notAfter                 TIMESTAMP, -- mutable by PATCH /sub/:id?notAfter=date and PATCH /package/:id?successor=id

    custom_price    NUMERIC, -- {deals,admin:rw}

    grantee         TEXT, -- or:
    managed_by      INT REFERENCES subscriptions,

    invoice_name    TEXT,
    invoice_email    TEXT,
);
--
CREATE INDEX IF NOT EXISTS subscriptions_index ON subscriptions (user,notAfter);
CREATE INDEX IF NOT EXISTS subscriptions_grantee_index ON subscriptions (grantee,notAfter) WITH (user,package);

CREATE TYPE IF NOT EXISTS transaction_kind AS ENUM (
    'deposit',
    'expense',
    'meta_subscription' -- TODO: includes whether the migration is 'safe' aka hidden in UI
);

-- TODO: GET /ledger
--        -> {admin} /:user
-- TODO: GET /ledger/export
--        -> {admin} all users
-- TODO: GET /negative {admin}
-- TODO: GET /negative/:user?period=5d
CREATE TABLE IF NOT EXISTS events {
    user    TEXT                NOT NULL,
    ts      TIMESTAMP           NOT NULL,
    hidden  BOOLEAN             NOT NULL, -- for example safe migrations
    source  TEXT                NOT NULL,
    content TEXT		NOT NULL,
};
--
CREATE INDEX IF NOT EXISTS events_index ON events (user,ts);
--
CREATE TABLE IF NOT EXISTS ledger (
    user    TEXT                NOT NULL,
    ts      TIMESTAMP           NOT NULL,
    source  TEXT                NOT NULL,

    -- ledger...
);
--
CREATE INDEX IF NOT EXISTS ledger_index ON ledger (user,ts);

-- TODO: Internal Billing routine
-- Follow dayofmonth, if DoM is out of range, use last day of month.
